---
title: 又记一次Android版本的变动
date: 2025-10-15 10:45:24
tags:
  - java
  - android
categories:
  - 学习笔记
---

# 问题情况

之前在处理关于恢复出厂设置的问题时,遇到了不允许后台执行系统性广播的问题,在此谨记

# 情况分析

因为工作需求,所以需要做读取 U 盘文件进行还原出厂设置的功能,当其他功能都做好后,发送广播却一直不生效,查看日志后发现了如下日志

```text
 10-14 09:59:16.478   731   813 W BroadcastQueue: Background execution not allowed: receiving Intent { act=android.intent.action.MASTER_CLEAR flg=0x10000010 (has extras) } to android/com.android.server.MasterClearReceiver
```

此日志的意思是该广播无法在后台状态执行.
经过网上查询后得知如下信息

```text
从 Android 8(API 26)开始,Google 引入了 后台执行限制(Background Execution Limits) :当应用不在前台(即后台运行、未在用户可见状态)时,它不能随意接收或触发广播、启动服务.
```

故该问题依旧是 Android8 之后的版本变更问题

# 解决过程

经过查询日志关键字后,在网上一篇文章中得知,对于该情况,在框架层源码中,有如下限制条件

路径在 frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java 中

代码行数在 1588-1617 之间

```java
  if (!skip) {

  final int allowed = mService.getAppStartModeLOSP(
    info.activityInfo.applicationInfo.uid, info.activityInfo.packageName,
    info.activityInfo.applicationInfo.targetSdkVersion, -1, true, false, false);
  if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
   // We won't allow this receiver to be launched if the app has been
   // completely disabled from launches, or it was not explicitly sent
   // to it and the app is in a state that should not receive it
   // (depending on how getAppStartModeLOSP has determined that).
   if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
    Slog.w(TAG, "Background execution disabled: receiving "
      + r.intent + " to "
      + component.flattenToShortString());
    skip = true;
   } else if ((((r.intent.getFlags()&Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0)
     || (r.intent.getComponent() == null
      && r.intent.getPackage() == null
      && ((r.intent.getFlags()
        & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0)
      && !isSignaturePerm(r.requiredPermissions))) && !skipBtState(r.intent.getAction())) {// xiaming add
    mService.addBackgroundCheckViolationLocked(r.intent.getAction(),
      component.getPackageName());
    Slog.w(TAG, "Background execution not allowed: receiving "
      + r.intent + " to "
      + component.flattenToShortString());
    skip = true;
   }
  }
 }
```

先列出常量的含义

```java
 /** @hide Mode for {@link IActivityManager#isAppStartModeDisabled}: normal free-to-run operation. */
 // 应用可以正常启动,接收广播,运行后台任务.没有被系统节制或限制。
 public static final int APP_START_MODE_NORMAL = 0;

 /** @hide Mode for {@link IActivityManager#isAppStartModeDisabled}: delay running until later. */
 // 系统允许该应用启动或接收广播，但会延迟执行，以防止过多后台唤醒。
 public static final int APP_START_MODE_DELAYED = 1;

 /** @hide Mode for {@link IActivityManager#isAppStartModeDisabled}: delay running until later, with
  * rigid errors (throwing exception). */
 // 与 DELAYED 类似，但系统会对违规操作抛出异常或记录更严格的警告。
 public static final int APP_START_MODE_DELAYED_RIGID = 2;

 /** @hide Mode for {@link IActivityManager#isAppStartModeDisabled}: disable/cancel pending
  * launches; this is the mode for ephemeral apps. */
 // 应用被系统判定为 完全禁止后台启动。所有后台广播、服务、进程启动请求都将被拒绝。
 public static final int APP_START_MODE_DISABLED = 3;
```

## 代码分析

如果不是正常应用

```java
   final int allowed = mService.getAppStartModeLOSP(
    info.activityInfo.applicationInfo.uid, info.activityInfo.packageName,
    info.activityInfo.applicationInfo.targetSdkVersion, -1, true, false, false);
    if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
       // ....

    }
```

然后判断应用是否被完全禁止后台启动执行

```java
 if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
    Slog.w(TAG, "Background execution disabled: receiving "
      + r.intent + " to "
      + component.flattenToShortString());
    skip = true;
 }
```

这里是核心代码,只要不满足此处的判断条件,应用就可以绕开系统的限制发送执行一些关键性危险广播

```java
if ((((r.intent.getFlags()&Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0)
     || (r.intent.getComponent() == null
      && r.intent.getPackage() == null
      && ((r.intent.getFlags()
        & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0)
      && !isSignaturePerm(r.requiredPermissions)))) {
    mService.addBackgroundCheckViolationLocked(r.intent.getAction(),
      component.getPackageName());
    Slog.w(TAG, "Background execution not allowed: receiving "
      + r.intent + " to "
      + component.flattenToShortString());
    skip = true;
   }
```

拆解开来,则是如下代码(从右往左)

如果没有系统签名权限

```java
 !isSignaturePerm(r.requiredPermissions)
```

如果 Intent 没有设置**FLAG_RECEIVER_INCLUDE_BACKGROUND**

```java
 (r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0
```

如果 Intent 是一个没有具体接受者的 Intent

```java
 r.intent.getComponent() == null && r.intent.getPackage() == null
```

如果设置了**FLAG_RECEIVER_EXCLUDE_BACKGROUND**

```java
 (r.intent.getFlags() & Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0
```

结合原代码逻辑则如下

```text
 设置不允许后台接受广播||(是隐式广播)&&(设置广播允许后台接收)&&(不具有系统签名权限)
```

则该判断生效于不允许广播被后台应用接收的系统隐式广播

## 解决办法

只需要让以上复杂判断其中几个条件失效就能成功解决该问题

4 个条件:

1. **FLAG_RECEIVER_EXCLUDE_BACKGROUND**

一般我们不需要加上这个标志,所以该标志可以跳过.

1. **隐式广播**

只需要让发送广播拥有一个明确的指向即可,包名和组件名其中一个不为 Null 就行

1. **FLAG_RECEIVER_INCLUDE_BACKGROUND**

这里需要发送广播加上这个标志**FLAG_RECEIVER_INCLUDE_BACKGROUND**

```java
/**
  * If set, the broadcast will always go to manifest receivers in background (cached
  * or not running) apps, regardless of whether that would be done by default.  By
  * default they will only receive broadcasts if the broadcast has specified an
  * explicit component or package name.
  *
  * NOTE: dumpstate uses this flag numerically, so when its value is changed
  * the broadcast code there must also be changed to match.
  *
  * @hide
  */
public static final int FLAG_RECEIVER_INCLUDE_BACKGROUND = 0x01000000;
```

该标志在源码中是隐藏的,所以需要直接在代码中直接写二进制代码

```java
intent.addFlags(0x01000000);
```

加上这个标志即可让如下判断失效

```java
r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0
```

1. **系统签名**

如果条件 3 不满足,则该条件判断即自动失效,无论结果如何

# 问题总结

综上所述,若想让广播生效,不被系统直接丢弃**MASTER_CLEAR**广播,则必须破坏上述四个条件之一,严格上讲,只需要破坏其中两个之一就行.
此外,对于系统级广播,建议使用具有系统签名的应用并确保前台运行,若是自定义广播,则建议显式写明对象包名或者组件名以避免被当成隐式广播.

若在进行 ROM 开发,则可自定义 BroadcastQueue 中代码以满足特定需求.

此记

# 引用文章

> 参考文章:[Background execution not allowed 分析](https://blog.csdn.net/sdsxtianshi/article/details/83625636)
