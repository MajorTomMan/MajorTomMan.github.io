---
title: 又记一次工作中的问题
date: 2025-10-16 15:07:39
tags:
---

# 问题情况

在处理设备的灯光时,在结束的时候,遇到了灯光没有按照预期情况结束的问题.
爆出如下错误

    ```text
        /**
        *  06-09 14:35:52.973890 2825  2849 W System.err: java.lang.InterruptedException
         * 06-09 14:35:52.973891 2825 2849 W System.err: at java.lang.Object.wait(Native
         * Method)
         * 06-09 14:35:52.974050 2825 2849 W System.err: at
         * java.lang.Object.wait(Object.java:442)
         * 06-09 14:35:52.974076 2825 2849 W System.err: at
         * java.lang.Object.wait(Object.java:568)
         * 06-09 14:35:52.974094 2825 2849 W System.err: at
         * java.lang.UNIXProcess.waitFor(UNIXProcess.java:208)
         * 06-09 14:35:52.974111 2825 2849 W System.err: at
         * xxx.xxx.xxx.ShellUtils.execCmd(ShellUtils.java:114)
         * 06-09 14:35:52.974142 2825 2849 W System.err: at
         * xxx.xxx.xxx.LightUtils.changeLightStatus(LightUtils.java:68)
         * 06-09 14:35:52.974160 2825 2849 W System.err: at
         * xxx.xxx.xxx.LightUtils.lambda$reflashLightStatus$0(LightUtils.java:30)
         * 06-09 14:35:52.974180 2825 2849 W System.err: at
         * xxx.xxx.xxx.LightUtils$$ExternalSyntheticLambda0.run(Unknown
         * Source:0)
         * 06-09 14:35:52.974195 2825 2849 W System.err: at
         * java.lang.Thread.run(Thread.java:920)
         */
    ```

# 情况分析

先查询该方法的官方注释

    ```java
    /**
     * Causes the current thread to wait, if necessary, until the
     * process represented by this {@code Process} object has
     * terminated.  This method returns immediately if the process
     * has already terminated.  If the process has not yet
     * terminated, the calling thread will be blocked until the
     * process exits.
     *
     * @return the exit value of the process represented by this
     *         {@code Process} object.  By convention, the value
     *         {@code 0} indicates normal termination.
     * @throws InterruptedException if the current thread is
     *         {@linkplain Thread#interrupt() interrupted} by another
     *         thread while it is waiting, then the wait is ended and
     *         an {@link InterruptedException} is thrown.
     */
    public abstract int waitFor() throws InterruptedException;
    ```

其中可以得知在阻塞期间,执行命令的线程被其他线程在阻塞期间强行中断后,会抛出这个中断异常

而查看代码中,涉及到这个方法的地方只有这里

```java
    public static void changeLightStatus(String status, File src) {
        if (isLightFileExist(src)) {
            if (src.getAbsolutePath().contains("xxx")) {
                ShellUtils.CommandResult commandResult = ShellUtils.execCmd(
                        new String[] { "echo " + status + " > xxxx" }, false, false,
                        mCallback);
            } else if (src.getAbsolutePath().contains("yyy")) {
                ShellUtils.CommandResult commandResult = ShellUtils.execCmd(
                        new String[] { "echo " + status + " > xxxx" }, false, false,
                        mCallback);
            }
        }
    }

    public static CommandResult execCmd(final String[] commands,
            final boolean isRooted,
            final boolean isNeedResultMsg) {
        int result = -1;
        if (commands == null || commands.length == 0) {
            return new CommandResult(result, "", "");
        }
        Process process = null;
        BufferedReader successResult = null;
        BufferedReader errorResult = null;
        StringBuilder successMsg = null;
        StringBuilder errorMsg = null;
        DataOutputStream os = null;
        try {
            process = Runtime.getRuntime().exec(isRooted ? "su" : "sh");
            result = process.waitFor();
        }
        catch(Exception e){
            // do somethings
        }

        return new CommandResult(
                result,
                successMsg == null ? "" : successMsg.toString(),
                errorMsg == null ? "" : errorMsg.toString());
    }


```

再看业务代码

```java
    public static void reflashLightStatus() {
        cleanLight(new File("xxx"), new File("yyy"));
        lightThread = new Thread(() -> {
            boolean lightStatus = false;
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    if (lightStatus) {
                        changeLightStatus("0", new File("xxx"));
                        changeLightStatus("1", new File("yyy"));
                    } else {
                        changeLightStatus("1", new File("xxx"));
                        changeLightStatus("0", new File("yyy"));
                    }
                    lightStatus = !lightStatus;
                    Thread.sleep(500);
                } catch (InterruptedException ignored) {
                    LogUtils.d(TAG, "------------------------InterruptedException------------------------------");
                    cleanLight(new File("xxx"), new File("yyy"));
                    Thread.currentThread().interrupt();
                    LogUtils.d(TAG, "reflashLightStatus: " + Thread.currentThread().isInterrupted());
                }
            }
        });
        lightThread.start();
    }

        public static void interrupt() {
        LogUtils.d(TAG, "------------------------interrupt------------------------------");
        if(lightThread!=null){
            lightThread.interrupt();
        }
    }

        @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause");
        LightUtils.interrupt();
    }
```


从以上业务代码来看,很显然,在onPause中,会直接调用线程的结束方法


# 解决过程


在读过方法的注释后,突然意识到,是不是在阻塞期间,刚好触发了线程的中断方法,然后导致执行命令的线程被灯光线程恰好中断了,从而导致抛出了这个异常

既然不能在执行阶段中断,那就只能等执行完成了再结束,既然如此,不如设计一个回调函数接口,让调用者可以在执行完成后得知完成后再结束进程


回调函数接口


```java
    public interface ShellCallback {
        void onSuccess();

        void onError();
    }
    private static ShellCallback mCallback = new ShellCallback() {
        @Override
        public void onSuccess() {
            LogUtils.d(TAG, "onSuccess: ");
            if (isNeedInterrupt) {
                // do somethings
            }
        }

        @Override
        public void onError() {
            LogUtils.d(TAG, "onError: ");
            if (isNeedInterrupt) {
                // do somethings
            }
        }
    };

```

在调用时,只要将中断方法改成如下代码,应该就可以了

```java
    public static void interrupt() {
        LogUtils.d(TAG, "------------------------interrupt------------------------------");
        if (!isNeedInterrupt) {
            isNeedInterrupt = true;
        }
    }
```


这样,就可以解决中断导致抛出中断异常的问题了

# 总结


通过设计回调,将一个可能会在阻塞时中断的代码,改成了可以拖延至执行完成后再中断,避免了灯状态不一样的问题
