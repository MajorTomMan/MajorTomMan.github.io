---
title: 记一次Android更新后的改动
date: 2025-10-10 14:25:02
tags:
  - java
  - markdown
  - blog
categories:
  - 学习笔记
---


今天在处理bug时,遇到了一个Android 8以后的改动,在此先记录一下


#  问题情况

 在处理一个需求的时候,需要对U盘的插入和状态变化进行监听,之前写的检测算法代码过于复杂,且在Android12的机器上无法正常运行,所以正好借此机会对于Android12的改动进行一个学习

# 前置知识
 在Android8之前,处理U盘的插入以及就绪情况需要监听系统发出的各个广播
 列一些常用的USb相关广播表如下
  Android 9 之前

  | 广播名字           | 广播字符串                                        | 广播代码                       |
  |:-----------------:|:-----------------------------------------------:|:-------------------------------:|
  | USB 设备插入       | android.hardware.usb.action.USB_DEVICE_ATTACHED  | ACTION_USB_DEVICE_ATTACHED      |
  | USB 设备移除       | android.hardware.usb.action.USB_DEVICE_DETACHED  | ACTION_USB_DEVICE_DETACHED      |
  | USB 配置更改       | android.hardware.usb.action.USB_STATE            | ACTION_USB_STATE                |
  | 存储检查中         | android.intent.action.MEDIA_CHECKING             | ACTION_MEDIA_CHECKING           |
  | 存储挂载完成       | android.intent.action.MEDIA_MOUNTED              | ACTION_MEDIA_MOUNTED            |
  | 存储插入但是尚未完成挂载动作      | android.intent.action.MEDIA_UNMOUNTED       | ACTION_MEDIA_UNMOUNTED      |
  | 存储正在卸载       | android.intent.action.MEDIA_EJECT                | ACTION_MEDIA_EJECT              |
  | 存储卸载完成       | android.intent.action.MEDIA_REMOVED            | ACTION_MEDIA_REMOVED          |
  | 存储扫描开始       | android.intent.action.MEDIA_SCANNER_STARTED      |     ACTION_MEDIA_SCANNER_STARTED    |
  | 存储扫描完成       | android.intent.action.MEDIA_SCANNER_FINISHED     | ACTION_MEDIA_SCANNER_FINISHED   |

  一般我们用到最多的是

  - **ACTION_MEDIA_MOUNTED**
  - **ACTION_MEDIA_REMOVED**
  - **USB_DEVICE_ATTACHED**
  - **USB_DEVICE_DETACHED**

  这四个广播,前两个代表存储的状态变更,而后两者则代表系统通知有存储插入机器,可以对其进行一些对应的操作,但是并不代表存储的状态是可用的,因为系统需要一些时间去对存储进行挂载操作,会大概在几百毫秒内完成,具体数值需要具体机器分析

  当存储处于Mounted状态时,就代表该存储在机器上可以进行一些针对文件的操作,比如查找,删除等
  代码如下:

  ```java

  public class UsbReceiver extends BroadcastReceiver {
      private static final String TAG = "UsbReceiver";

      @Override
      public void onReceive(Context context, Intent intent) {
          String action = intent.getAction();
          LogUtils.d(TAG, "action->" + action);
          if (action != null) {
              switch (action){
                  case "android.intent.action.MEDIA_MOUNTED":
                     // do something
                    break;
                  case "android.intent.action.MEDIA_REMOVED":
                    // do something
              }
          }
      }
  }
  ```

  注册广播

  ```xml
          <receiver
            android:name=".receiver.UsbReceiver"
            android:enabled="true"
            android:exported="true"
            android:priority="1000">
            <intent-filter>
                <action android:name="android.intent.action.MEDIA_MOUNTED" />
                <action android:name="android.intent.action.MEDIA_REMOVED" />
            </intent-filter>
        </receiver>
  ```

  以上代码可以在Android8以前的机器上正常使用,需要注意的是
  **动态注册的广播接收者无法在尚未启动过应用的情况下获取系统广播**和**静态注册的广播接收者则会在系统完成启动后在收到对应广播时由系统代为转发至应用广播接收器**,所以想在开机时获取开机广播再进行调用某个应用的话,静态注册广播会是更好的选择

  以上是Android8之前的系统广播有关前置知识

# 问题情况分析

  在Android8之后,Google加强了广播的安全性,为了限制后台应用滥用广播和提高性能和电池续航,对于隐式广播(没有指定接收者的广播,系统会根据所有应用中**AndroidManifest.xml**中注册的**Receiver**中声明的**intent-fliter**来查找需要处理该广播的应用)而言,Google将很多静态可以接收到的广播都转为了动态注册才能接收到对应的广播.
  **具体哪些广播被允许静态注册可以查阅 Google 官方文档的 [Implicit Broadcast Exceptions](https://developer.android.com/develop/background-work/background-tasks/broadcasts/broadcast-exceptions).**
  其中也包括**ACTION_MEDIA_MOUNTED**这个广播.
  所以在需要应用在未启动且冷启动也无的情况下处理USB设备的插拔带来了很大的麻烦,但是Google并没有彻底堵住获取这个广播的途径,对于需要获取这个广播的应用,Google提供了新的API来处理这个情况

  ##  StorageManager.StorageVolumeCallback

  代码如下

  ```java
      import android.os.Environment;
      import android.os.storage.StorageManager;
      import android.os.storage.StorageVolume;

      private class UsbStorageVolumeCallback extends StorageManager.StorageVolumeCallback {
        @Override
        public void onStateChanged(@NonNull StorageVolume volume) {
            LogUtils.d(TAG, "volume state changed");
            LogUtils.d(TAG, "volume->" + volume);
            LogUtils.d(TAG,"volume state ->"+volume.getState());
            LogUtils.d(TAG,"volume context:"+context);
            if(volume.isRemovable()){
                LogUtils.d(TAG, "usb device is removable");
                if(volume.getState().equals(Environment.MEDIA_MOUNTED)){
                    LogUtils.d(TAG, "usb device mounted");
                    // do somethings
                }
            }
        }
    }
  ```

  注册回调函数

  ```java
      StorageManager storageManager = getSystemService(StorageManager.class);
      UsbStorageVolumeCallback usbStorageVolumeCallback =new UsbStorageVolumeCallback();
      storageManager.registerStorageVolumeCallback(executor,usbStorageVolumeCallback);
  ```

  通过这个回调函数,我们可以在Android8之后让应用获取广播以对USB设备进行一些操作,但是需要指出的一点是,不能直接通过静态注册这个广播接收器来获取该广播,我们需要曲线救国,通过框架层给出的**USB_DEVICE_ATTACHED**广播,我们可以知道有设备进行插入,然后通过注册回调函数,我们可以在系统完成挂载的第一时间获取设备的挂载信息

  代码如下

  ```java

public class UsbReceiver extends BroadcastReceiver {
    private static final String TAG = "UsbReceiver";

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        LogUtils.d(TAG, "action->" + action);
        if (action != null) {
            switch (action){
                case "android.hardware.usb.action.USB_DEVICE_ATTACHED":
                    // do somethings
                    break;
            }
        }
    }
}
```

注册广播

```xml
        <receiver
            android:name=".receiver.UsbReceiver"
            android:enabled="true"
            android:exported="true"
            android:priority="1000">
            <intent-filter>
                <action android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED" />
                <action android:name="android.hardware.usb.action.USB_DEVICE_DETACHED" />
            </intent-filter>
        </receiver>
```

通过注册这个广播,通过Google允许的静态接收广播**USB_DEVICE_ATTACHED**,可以间接注册回调函数

注册服务,避开Google对于广播处理时间只有10秒的限制,让需要长时间作业的任务通过服务来继续

```java
public class UsbReceiver extends BroadcastReceiver {
    private static final String TAG = "UsbReceiver";

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        LogUtils.d(TAG, "action->" + action);
        if (action != null) {
            switch (action){
                case "android.hardware.usb.action.USB_DEVICE_ATTACHED":
                    JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
                    JobInfo service = new JobInfo.Builder(
                            2333,
                            new ComponentName(context,UsbService.class)
                    ).setOverrideDeadline(0).build();
                    LogUtils.d(TAG, "usb device attached, starting UsbService");
                    jobScheduler.schedule(service);
                    break;
            }
        }
    }
}
```

服务中的代码


```java
public class UsbService extends JobService {
    private static final String TAG = "UsbReceiver";
    private static final ExecutorService executor = Executors.newSingleThreadExecutor();
    private Context context;
    private StorageManager storageManager;
    private final UsbStorageVolumeCallback usbStorageVolumeCallback =new UsbStorageVolumeCallback();
    private boolean isRegister = false;
    @Override
    public boolean onStartJob(JobParameters params) {
        LogUtils.d(TAG, "UsbService started");
        // 防止重复注册导致重复执行的问题
        if(storageManager == null){
            storageManager = getSystemService(StorageManager.class);
        }
        LogUtils.d(TAG, "register usb storage volume callback");
        if(storageManager != null){
            LogUtils.d(TAG, "storageManager->" + storageManager);
            // 防止重复注册回调函数
            if(isRegister){
                LogUtils.d(TAG, "usb storage volume callback already registered, skip");
                return true;
            }
            storageManager.registerStorageVolumeCallback(executor,usbStorageVolumeCallback);
            isRegister = true;
        }
        else{
            LogUtils.e(TAG, "storageManager is null, cant register usb storage volume callback");
        }
        return true;
    }

    @Override
    public boolean onStopJob(JobParameters params) {
        if (isRegister && storageManager != null) {
            storageManager.unregisterStorageVolumeCallback(usbStorageVolumeCallback);
            isRegister = false;
        }
        return false;
    }
}
```

# 总结

  通过以上的分析,在Android8之后的应用,可以通过**StorageManager**和**UsbStorageVolumeCallback**以及**ACTION_USB_DEVICE_ATTACHED**的配合来间接完成Android8之前只需要注册广播就可以完成的任务
